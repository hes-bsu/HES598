---
title: "Advanced Topics: Network Visualization"
author: "Molly Levy"
date: "4/3/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduce your problem

My research aims to address conflicts on multiple use landscapes. Within my study area, the Thunder Basin ecoregion (TBER), there are multiple different types of stakeholder groups and actors with a variety of vested interest in different land uses supported by TBER. Given the diversity of actors involved, conflict often arises when the goals of different groups do not align. I am interested in examining the network relationships and degrees of interconnectedness between different groups and individuals involved in the management of TBER. As such, I will be testing and evaluating different packages frequently used in the preparation of network diagrams in order to determine how to efficiently build and visualize a network diagram. 

## Introduce the packages

library(igraph)

igraph is a library and R package for network analysis. One online resource described igraph as "the  most important R package when it comess to build network diagrams." This package will be useful for building a network diagram from adjacency matrix, edge list, literal list of connections, and more. igraph also provides three different functions for visualizations. This package emphasizes efficiency and portability, so will be able  to try different combinations of network building and visualization. 

library(networkD3)

The networkD3 package allows to build interactive network diagrams with R, including zoom, hover nodes, reorganize the layout. This package will provide features for dynamic data manipulation and visualization and allows users to become active participants in data visualization process by allowing users to explore data points, hierarchies among the data, filter data by groups, and similar. It also provides pseudo-data to use to play around with. This package can plot many different types of networks and is also supposed to interact well with the igraph package.  

```{r}
library(igraph)
library(networkD3)
```

## Analysis/processing step 1 - igraph

In this step, I am creating a network diagram using the igraph package. My goal is to create a "simple" (non-interactive) network diagram that displays a coauthor network of researchers who have or have not published with one another. Researchers are the nodes, represented as dots. If 2 researchers have published at least one scientific paper together, they are connected. The node size will be proportional to the number of coauthors. I'm also using the colormap packge to distinguish between different "clusters" within the network, which will make it easier for the viewer to interpret the network structure on their own.

For the network layout algorithm, I am going to use the Fruchterman-Reingold algorithm, which is a force-directed method that is probably the most widely used algorithm. Finding the most optimal position for each node is tricky and will impact the output, so future work should evaluate how the use of different algorithms impacts the interpretation of the final network chart. 

```{r}
#creating a network diagram with igraph

#load packages
library(tidyverse)
library(viridis)
library(patchwork)
library(ggraph)
library(igraph)
library(networkD3)
library(colormap)

# load data
dataUU <- read.table("https://raw.githubusercontent.com/holtzy/data_to_viz/master/Example_dataset/13_AdjacencyUndirectedUnweighted.csv", header=TRUE)

# transform the adjacency matrix in a long format
connect <- dataUU %>% 
  gather(key="to", value="value", -1) %>%
  mutate(to = gsub("\\.", " ",to)) %>%
  na.omit() 

# number of connection per person
c( as.character(connect$from), as.character(connect$to)) %>%
  as.tibble() %>%
  group_by(value) %>%
  summarize(n=n()) -> coauth
colnames(coauth) <- c("name", "n")

# create a graph object with igraph
mygraph <- graph_from_data_frame( connect, vertices = coauth, directed = FALSE )

# find community
com <- walktrap.community(mygraph)

#Reorder dataset and make the graph
coauth <- coauth %>% 
  mutate( grp = com$membership) %>%
  arrange(grp) %>%
  mutate(name=factor(name, name))

# keep only 10 first communities
coauth <- coauth %>% 
  filter(grp<16)

# keep only those people in edges
connect <- connect %>%
  filter(from %in% coauth$name) %>%
  filter(to %in% coauth$name)

# create a graph object with igraph
mygraph <- graph_from_data_frame( connect, vertices = coauth, directed = FALSE )

# prepare a vector of n color in the viridis scale
mycolor <- colormap(colormap=colormaps$viridis, nshades=max(coauth$grp))
mycolor <- sample(mycolor, length(mycolor))

# make the graph
ggraph(mygraph, layout="fr") + 
  geom_edge_link(edge_colour="black", edge_alpha=0.2, edge_width=0.3, fold=TRUE) +
  geom_node_point(aes(size=n, color=as.factor(grp), fill=grp), alpha=0.9) +
  scale_size_continuous(range=c(0.5,8)) +
  scale_color_manual(values=mycolor) +
  geom_node_text(aes(label=ifelse(n>6, as.character(name), "")), angle=65, hjust=rep(c(0,1),58), nudge_y = rep(c(0.5,-0.5),58), size=2.3, color="grey") +
  theme_void() +
  theme(
    legend.position="none",
    plot.margin=unit(c(0,0,0,0), "null"),
    panel.spacing=unit(c(0,0,0,0), "null")
  ) +
  expand_limits(x = c(-1.2, 1.2), y = c(-1.2, 1.2)) 
```

## Outcomes - igraph 

I am pleased with how this code turned out. It returned a functional network diagram, with changes in color denoting different clusters and node sizing proportional to the number of co-authors. The final graph depicts papers where Vincent Ranwez was involved, and the network of coauthors he published with. From the diagram, we can see that a few gorups of rsearchers are isolated. In the middle, there is a massife network of researchers, which demonstrate that the people Vincent Ranwez publish with more often are also more linked together. 

One thing I learned from this chart is that network graphs, at least in igraph, are not very good at labeling every single pointL the names start to overlap the edges which can make the figure unreadable. Further research on the internet suggested that an arc diagram might be a useful alternative to a network chart if you want to show all labels. 

The critical step in this code is using igraph to create a graph object, which is then plotted using ggraph. I also chose to limit the number of communities/connections that were displayed in this chart in order to keep or more readable, but careful thought needs to be given to each individual dataset before choosing to exclude portions from the visualization and analysis. 

Given your psuedo code, where is the critical step? What packages and functions are you considering to help you complete this step? Why did you choose them? 

## Analysis/processing step 2 - networkD3

In this step, I am using the same dataset from above to create an interactive network diagram using the networkD3 package. Given that the chart is meant to be interactive, I want users to be able to zoom into specific clusters in order to see researcher names or get a more detailed view of specific areas of the network. I also want to be able to export/save the interactive network "widget" so that this visualization could be used online for a project website. 

```{r}
# using network D3 to create interactive graph

#load the libraries - tell us which packages you're using and why
library(tidyverse)
library(viridis)
library(patchwork)
library(ggraph)
library(igraph)
library(networkD3)

#load your data - Dataset represents the co-authors network of Vincent Ranwez. Peoople having published at least one research paper with him are represented by a node. If two people have been listed on the same publication at least once, they are connected by a link.
dataUU <- read.table("https://raw.githubusercontent.com/holtzy/data_to_viz/master/Example_dataset/13_AdjacencyUndirectedUnweighted.csv", header=TRUE)


## Transform the adjacency matrix in a long format
connect <- dataUU %>% 
  gather(key="to", value="value", -1) %>%
  na.omit()

# Number of connection per person
c( as.character(connect$from), as.character(connect$to)) %>%
  as.tibble() %>%
  group_by(value) %>%
  summarize(n=n()) -> coauth
colnames(coauth) <- c("name", "n")

# NetworkD3 format
graph=simpleNetwork(connect)

# Plot
simpleNetwork(connect,     
        Source = 1,                 # column number of source
        Target = 2,                 # column number of target
        height = 880,               # height of frame area in pixels
        width = 1980,
        linkDistance = 10,         # distance between node. Increase this value to have more space between nodes
        charge = -4,              # numeric value indicating either the strength of the node repulsion (negative value) or attraction (positive value)
        fontSize = 5,              # size of the node names
        fontFamily = "serif",       # font og node names
        linkColour = "#666",        # colour of edges, MUST be a common colour for the whole graph
        nodeColour = "#69b3a2",     # colour of nodes, MUST be a common colour for the whole graph
        opacity = 0.9,              # opacity of nodes. 0=transparent. 1=no transparency
        zoom = T                    # Can you zoom on the figure?
        )

# if you want to save the widget...

p <- simpleNetwork(connect,     
        Source = 1,                 
        Target = 2,                 
        height = 880,              
        width = 1980,
        linkDistance = 10,        
        charge = -4,              
        fontSize = 5,             
        fontFamily = "serif",       
        linkColour = "#666",        
        nodeColour = "#69b3a2",     
        opacity = 0.9,              
        zoom = T                    
        )

# library(htmlwidgets)
# make sure to set working directory to where you want the widget to save
# saveWidget(p, file=paste0( getwd(), "/HtmlWidget/networkInteractive2.html"))
```


## Outcomes - networkD3

I think this interactive network is really cool - I like that you can zoom in to different areas of the map to get a more detailed look at specific nodes and researcher's names. I also like that you can save this widget, so that it can then be displayed on a website or a different venue. However, I do think this chart is a little hard to read. In the future, I would like to play around with the node size (and maybe weighting the nodes like we did in the igraph chart) to see if I can make this diagram more readable.

## Evaluate your choices - igraph
```{r}
library(microbenchmark)
library(profvis)

# how long does it take to create a graph object with igraph?

graph.time <- system.time(mygraph <- graph_from_data_frame( connect, vertices = coauth, directed = FALSE ))

graph.time

# how long does it take to make the actual network graph?

plot.time <- system.time(ggraph(mygraph) + 
  geom_edge_link(edge_colour="black", edge_alpha=0.2, edge_width=0.3, fold=TRUE) +
  geom_node_point(aes(size=n, color=as.factor(grp), fill=grp), alpha=0.9) +
  scale_size_continuous(range=c(0.5,8)) +
  scale_color_manual(values=mycolor) +
  geom_node_text(aes(label=ifelse(n>6, as.character(name), "")), angle=65, hjust=rep(c(0,1),58), nudge_y = rep(c(0.5,-0.5),58), size=2.3, color="grey") +
  theme_void() +
  theme(
    legend.position="none",
    plot.margin=unit(c(0,0,0,0), "null"),
    panel.spacing=unit(c(0,0,0,0), "null")
  ) +
  expand_limits(x = c(-1.2, 1.2), y = c(-1.2, 1.2)))

plot.time

# is there a rate-limiting step in my simple network diagram code?

network.prof <- profvis(expr = {
#load data 
dataUU <- read.table("https://raw.githubusercontent.com/holtzy/data_to_viz/master/Example_dataset/13_AdjacencyUndirectedUnweighted.csv", header=TRUE)
# Transform the adjacency matrix in a long format
connect <- dataUU %>% 
  gather(key="to", value="value", -1) %>%
  mutate(to = gsub("\\.", " ",to)) %>%
  na.omit() 
# Number of connection per person
c( as.character(connect$from), as.character(connect$to)) %>%
  as.tibble() %>%
  group_by(value) %>%
  summarize(n=n()) -> coauth
colnames(coauth) <- c("name", "n")
# Create a graph object with igraph
mygraph <- graph_from_data_frame( connect, vertices = coauth, directed = FALSE )
# Find community
com <- walktrap.community(mygraph)
#Reorder dataset and make the graph
coauth <- coauth %>% 
  mutate( grp = com$membership) %>%
  arrange(grp) %>%
  mutate(name=factor(name, name))
# keep only 10 first communities
coauth <- coauth %>% 
  filter(grp<16)
# keep only this people in edges
connect <- connect %>%
  filter(from %in% coauth$name) %>%
  filter(to %in% coauth$name)
# Create a graph object with igraph
mygraph <- graph_from_data_frame( connect, vertices = coauth, directed = FALSE )
# prepare a vector of n color in the viridis scale
mycolor <- colormap(colormap=colormaps$viridis, nshades=max(coauth$grp))
mycolor <- sample(mycolor, length(mycolor))
# Make the graph
ggraph(mygraph, layout="fr") + 
  geom_edge_link(edge_colour="black", edge_alpha=0.2, edge_width=0.3, fold=TRUE) +
  geom_node_point(aes(size=n, color=as.factor(grp), fill=grp), alpha=0.9) +
  scale_size_continuous(range=c(0.5,8)) +
  scale_color_manual(values=mycolor) +
  geom_node_text(aes(label=ifelse(n>6, as.character(name), "")), angle=65, hjust=rep(c(0,1),58), nudge_y = rep(c(0.5,-0.5),58), size=2.3, color="grey") +
  theme_void() +
  theme(
    legend.position="none",
    plot.margin=unit(c(0,0,0,0), "null"),
    panel.spacing=unit(c(0,0,0,0), "null")
  ) +
  expand_limits(x = c(-1.2, 1.2), y = c(-1.2, 1.2))
}, interval = 0.01, prof_output = 'fstr-prof' ) 

network.prof

```

## Evaluate your choices - networkD3

```{r}
library(microbenchmark)
library(profvis)

#How long does it take to transform the adjacency matrix into the appropriate dataframe?

transform.time <- system.time(connect <- dataUU %>% 
  gather(key="to", value="value", -1) %>%
  na.omit())

transform.time

#How long does it take for my system to compute an interactive network diagram?

plot.time <- system.time(simpleNetwork(connect,     
        Source = 1,                 # column number of source
        Target = 2,                 # column number of target
        height = 880,               # height of frame area in pixels
        width = 1980,
        linkDistance = 10,         # distance between node. Increase this value to have more space between nodes
        charge = -4,              # numeric value indicating either the strength of the node repulsion (negative value) or attraction (positive value)
        fontSize = 5,              # size of the node names
        fontFamily = "serif",       # font og node names
        linkColour = "#666",        # colour of edges, MUST be a common colour for the whole graph
        nodeColour = "#69b3a2",     # colour of nodes, MUST be a common colour for the whole graph
        opacity = 0.9,              # opacity of nodes. 0=transparent. 1=no transparency
        zoom = T                    # Can you zoom on the figure?
        ))

plot.time

#is there a rate-limiting step in this code chunk?
 
interactive.prof <- profvis(expr = {
  #load packages
library(tidyverse)
library(viridis)
library(patchwork)
library(ggraph)
library(igraph)
library(networkD3)
#load your data
dataUU <- read.table("https://raw.githubusercontent.com/holtzy/data_to_viz/master/Example_dataset/13_AdjacencyUndirectedUnweighted.csv", header=TRUE)
## Transform the adjacency matrix in a long format
connect <- dataUU %>% 
  gather(key="to", value="value", -1) %>%
  na.omit()
# Number of connection per person
c( as.character(connect$from), as.character(connect$to)) %>%
  as.tibble() %>%
  group_by(value) %>%
  summarize(n=n()) -> coauth
colnames(coauth) <- c("name", "n")
# NetworkD3 format
graph=simpleNetwork(connect)
# Plot
simpleNetwork(connect,     
        Source = 1,                 # column number of source
        Target = 2,                 # column number of target
        height = 880,               # height of frame area in pixels
        width = 1980,
        linkDistance = 10,         # distance between node. Increase this value to have more space between nodes
        charge = -4,              # numeric value indicating either the strength of the node repulsion (negative value) or attraction (positive value)
        fontSize = 5,              # size of the node names
        fontFamily = "serif",       # font og node names
        linkColour = "#666",        # colour of edges, MUST be a common colour for the whole graph
        nodeColour = "#69b3a2",     # colour of nodes, MUST be a common colour for the whole graph
        opacity = 0.9,              # opacity of nodes. 0=transparent. 1=no transparency
        zoom = T                    # Can you zoom on the figure?
        )}, interval = 0.01, prof_output = 'fstr-prof' )


interactive.prof

```

When creating a network diagram (simple or interactive), actually reading the dataset and then converting it into the appropriate format are the longest steps, then followed by creating the actual interactive network diagram. This is useful information as it indicates that the size of the data sample you are using could have impacts on the efficiency of this process. While this code converts the loaded data into a frame that can then be used for network visualization, a possible shortcut could be to format your dataset ahead of time so that it is already in the correct format, this saving the time of having R re-format the data for you. However, this could also be really time-intensive to do by hand, and letting R manipulate the data might actually be the quickest route, even if it is the longest step in the process. 


## How much slower is it to create a fancy, interactive network diagram instead of just a "normal," standard visualization?
```{r}
network.prof
interactive.prof
```

It takes 120 milliseconds to create the simple network, and only 30 milliseconds to create the interactive diagram, which I found surprising; I had assumed it would take longer to make the interactive diagram since the output is more complex. However, I wonder if the fact that the nodes are different colors and sizes in the simple diagram causes this output to take more time, whereas the nodes in the interactive diagram have a more uniform appearance. Future work should address if it still faster to make the interactive diagram when everything is held constant - color, size of nodes, etc. From the profile summary, the slowest step in the simple network diagram appears to be making the actual plot (whereas the longest step in the interactive diagram is just reading the actual data), which supports my hypothesis that it is the customizations made to the nodes that is slowing this process down. However, both networks were relatively quick to make using this dataset, but a larger dataset could impede the processing time.

## Show us your final product
```{r}
# Simple network diagram using igraph
ggraph(mygraph, layout="fr") + 
  geom_edge_link(edge_colour="black", edge_alpha=0.2, edge_width=0.3, fold=TRUE) +
  geom_node_point(aes(size=n, color=as.factor(grp), fill=grp), alpha=0.9) +
  scale_size_continuous(range=c(0.5,8)) +
  scale_color_manual(values=mycolor) +
  geom_node_text(aes(label=ifelse(n>6, as.character(name), "")), angle=65, hjust=rep(c(0,1),58), nudge_y = rep(c(0.5,-0.5),58), size=2.3, color="grey") +
  theme_void() +
  theme(
    legend.position="none",
    plot.margin=unit(c(0,0,0,0), "null"),
    panel.spacing=unit(c(0,0,0,0), "null")
  ) +
  expand_limits(x = c(-1.2, 1.2), y = c(-1.2, 1.2)) 

# Interactive network diagram using networkD3
simpleNetwork(connect,     
        Source = 1,                 # column number of source
        Target = 2,                 # column number of target
        height = 880,               # height of frame area in pixels
        width = 1980,
        linkDistance = 10,         # distance between node. Increase this value to have more space between nodes
        charge = -4,              # numeric value indicating either the strength of the node repulsion (negative value) or attraction (positive value)
        fontSize = 5,              # size of the node names
        fontFamily = "serif",       # font og node names
        linkColour = "#666",        # colour of edges, MUST be a common colour for the whole graph
        nodeColour = "#69b3a2",     # colour of nodes, MUST be a common colour for the whole graph
        opacity = 0.9,              # opacity of nodes. 0=transparent. 1=no transparency
        zoom = T                    # Can you zoom on the figure?
        )
```


## Reflect
From this exercise, I gained experience working with two different packages that can both be used to create network diagrams. Both diagrams had their strengths and weaknesses. The simple diagram was more visually appealing (in my opinion) and was also able to communicate more information through the color and size of the nodes, but took longer to make. However, the interactive diagram is more "fun" and allows the viewer to scroll around and zoom to various areas of the chart, which also makes it easier to see the individual labels on the nodes. For my next steps, I want to play around with different algorithms used to determine the network structure. I used the Fruchterman-Reingold algorithm because it is most commonly used, but I want to obtain a better understanding of which algorithms are more approriate in different scenarios, and how different algorithms impact the processing time. Additionally, I would also like to play with the interactive diagram to see if I can customize the nodes in the same way I was able to with the simple diagram, and see whether the profiles for the two charts will become more similar after doing so. In the future, I'm hoping to explore more interactive diagrams that could be displayed on a project website to communicate some of the results of my proejct in an engaging manner. 