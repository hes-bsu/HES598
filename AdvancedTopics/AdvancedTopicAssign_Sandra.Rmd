---
title: "Advanced Topic Instructions"
author: "Sandra Velazco"
date: "4/13/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


SAVE YOUR FILE IN THE AdvancedTopics FOLDER IN THE GIT REPO

## Introduce your problem

In the tropical Andes, bracken fern due to its vigor and rapid colonization inhibits the establishment of the native plants, delaying the recovery of the montane forest. My study investigate whether the distance and shape of Bracken fern-dominated patches from the forest affect natural regeneration in these patches in the north of Peru between 2014 and 2019. Satellite imagery of the Sentinel sensor from the last five years will be used to measure the vegetation index (NDVI) in each patch. Temporal changes in vegetation index within and between patches will be used as a measure of native vegetation recovery in the region.

An expected result is that the configuration of Bracken fern patches will determine natural regeneration in these degraded areas. So, my first step will be to measure the distance from each pixel to the forest edge, applying the nearest neighbor analysis. To accomplish this first step, I will use sample data to test the efficiency of different packages in analyzing the distance of pixels located in the Bracken fern patches to the forest.



## PSUEDOCODE!!
Before you get started programming all of the potential things you could do during the course of this demo. Lay out the steps you'll need to get there (see below for what I mean). You don't have to actually code these things (yet) just help us see how you're approaching the problem.
```{r}
#load the libraries

#library(maptools)
library(googledrive)# I used this package to download files from googledrive into Rmarkdonw
options(
  gargle_oauth_cache = ".secrets",
  gargle_oauth_email = TRUE
)

library(here)# It was used to define file paths.
library(raster)# I used it for raster file
#library(rasterVis)
library(rgdal)# This package allowed to project and transform spatial data.
#library(viridis)
#library(scales)
#library(maptools)
#library(rgeos)

library(sp)# Used for shapefiles
library(sf)# Used for dataframe
library(dplyr)# Used for organize dataframe
#library(data.table)  
library(RColorBrewer)# Used to add color for plotting maps
#library(ggplot2)
#library(microbenchmark)


#Donwloading files from googledrive:
folder_url <- "https://drive.google.com/drive/folders/1r8XsNTTKWCiWHSxR_ldISpLHzZJbla3o"

folder <- drive_get(as_id(folder_url))
gdrive_files <- drive_ls(folder)
lapply(gdrive_files$id, function(x) drive_download(as_id(x),
                                                   path = paste0(here::here("datatemp/original/"), "/",gdrive_files[gdrive_files$id==x,]$name), overwrite = TRUE))

#Uploading files from directory
pixels <- read.csv(here::here("datatemp/original/data_sample.csv"), stringsAsFactors = FALSE)
str(pixels)

elev=raster::raster(here::here("datatemp/original/raster.tif"))
elev

#Check the data: pixels file
class(pixels)
dim(pixels)
colnames(pixels)
ncol(elev)
nrow(elev)

######## Step1: Extract elevation data from raster file
## Project pixels dataframe using elev raster projection
crs
elev@crs
pixels_spdf <- SpatialPointsDataFrame(
              pixels[,1:2],proj4string=elev@crs, pixels)
class(pixels)

## I used extract funtion to get elevation data from the raster image.
pixel_elev <- raster::extract(elev, # raster layer
              pixels_spdf,   # SPDF with pixels
              df=TRUE)         # return a dataframe
pixel_elev

## Then I grabbed the name of the ID_pixel from the pixels_spdf
pixel_elev$pix_id<- pixels_spdf$ID_pixel
pixel_elev$pix_id

## Fix the column names
names(pixel_elev) <- c('ID','elev','pix_id')
pixel_elev


## The pixels and pixel_elev data were merged, using merge function from package base.
pixelelev <- merge(pixels, pixel_elev, by.x = 'ID_pixel', by.y = 'pix_id')
pixelelev

## Then I plot pixels in raster
#plot(elev)
#myCol <- terrain.colors(6)
#plot(elev, col=myCol)
#points(pixels$Long, pixels$Lat, cex = 0.5)


######## Step2: Assign the UTM projection to pixelelev and to raster file to measure distance using different package.

######### transform coordinates from lat long to UTM for measuring distance in raster files.

CRS("+init=epsg:32717")
#crs = " +init=epsg:32717 +proj=utm +zone=17 +south +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"

## Use projection to reproject pixelelev to UTM.
LongLatToUTM<-function(x,y,ID,zone){
          xy <- data.frame(ID = ID, x = x, y = y)
          coordinates(xy) <- c("x", "y")
          proj4string(xy) <- CRS("+proj=longlat +datum=WGS84")
          res <- spTransform(xy, CRS(paste("+proj=utm +south +zone=",zone," +ellps=WGS84 +units=m +no_defs +towgs84=0,0,0", sep='')))
          return(as.data.frame(res))
          }

##Assign the UTM zone and run the function
x=LongLatToUTM(pixelelev$Long,pixelelev$Lat,ID=pixelelev$ID_pixel,17)

## Merge the new UTM coordinates to the locations dataframe.
x$ID_pixel=x$ID
pixelelev= merge(pixelelev,x,by="ID_pixel")
head(pixelelev)

##change names of variables in dataframe #######
names(pixelelev)
df=pixelelev
names(df)=c("ID_pixel","Long","Lat","ID_veg","loc","ndvi","ID.x","z","ID.y","x","y")
names(df)

## Arrange according ID_veg
df <- df[order(df$ID_veg),]
df


#library(plyr)
#count(df, "ID_veg")
#df
#  ID_veg freq
# 1   fern   56
# 2 forest   40

##Define the rpjection to reproject the raster file from lat long into UTM
CRS("+init=epsg:32717")
sr <- "+proj=utm +south +zone=17 +ellps=WGS84 +units=m +no_defs +towgs84=0,0,0"

##Reproject Raster
elev_utm <- projectRaster(elev, crs = sr)

# Write the RasterLayer to directory
#writeRaster(elev_utm, filename="C:/Users/Sandra/Desktop/R files/Stats/RMarkdownAssignment_Sandra/datatemp/elev_utm.tif", overwrite=TRUE)

### plot raster
#plot(elev_utm)
#plot(elev_utm, main="elev", xlab="East", ylab="North")
#myCol <- terrain.colors(6)


#############coord

#library(dplyr)
#library(tidyverse)
#library(Rfast)
#library(sp)
#library(sf)


#df$East=df$x
#df$North=df$y
#colnames(df)
#class(df)

##Transform df dataframe into sf object and assign geometry.
coordnt=st_as_sf(df, coords = c("x", "y"), crs = ("+init=epsg:32717"),stringsAsFactors = FALSE)
class(coordnt)
coordnt
#coordnt <- st_as_sf(df_spat, df_spat = c("x", "y"),
 #                crs = ("+init=epsg:32717"), stringsAsFactors = FALSE)
#class(coordnt)
#colnames(coordnt)

##############################################################
################  Gdistance package #####$####################
##############################################################

library(gdistance)# This package is used to measure distance using spatial data.
library(Matrix)# This package allow getting distance matrix
library(igraph)# Used to plot

######## Step2: Create a transition matrix from the elev_utm raster file
### The units of height and distance should be identical.
### slope = differenceinheight/distancetravelled
altDiff <- function(x){x[2] - x[1]}
hd <- transition(elev_utm, altDiff, 8, symm=FALSE)
str(hd)
plot(raster(hd), sub="slope (height diff / distance)", cex=0.8)

##Then we use the function geoCorrection to divide by the distance between cells.
slope <- geoCorrection(hd, scl=FALSE)

# inspect a transition matrix for slope
round(transitionMatrix(slope),3)

## Restrict the calculaton of speed to adjacent cells
adj <- adjacent(elev_utm, cells=1:ncell(elev_utm), pairs=TRUE, directions=8)
speed <- hd
##Ajust the distance using the slope(diagonal distance)
speed[adj] <- 6 * exp(-3.5 * abs(slope[adj] + 0.05))
##Plot raster speed
plot(raster(speed))
##Geocorrect again for distance to create a time matrix.
conductance <- geoCorrection(speed)
class(conductance)

## now calculate distance using the least cost path
dist2 <- costDistance(conductance,
                      fromCoords = as(as_Spatial(coordnt[1:56,]), "SpatialPoints"),
                      toCoords = as(as_Spatial(coordnt[-(1:56),]), "SpatialPoints"))

##drop geometry
coord_df <- st_drop_geometry(coordnt)

### Subset columns from datafrane coordnt
ID_pixels<-coord_df[, 1]
ID_pixels

### Assign ID names to row and columns of dist2 matrix
rownames(dist2) <- ID_pixels[1:56]
dist2
colnames(dist2) <- ID_pixels[57:96]
dist2

## Convert dist2 matrix into dataframe using reshape2 package
library(reshape2)
#rename heads of columns of dist2 matrix
dist2_id <- melt(as.matrix(dist2), varnames = c("fern", "forest"))

## convert into dataframe
dist2_id[dist2_id$fern > dist2_id$forest,]
class(dist2_id)

## Select minimun distance values.
library(dplyr)
summ_fern_value<- dist2_id %>% 
  group_by(fern) %>% 
  summarise(min = min(value, na.rm = TRUE))
summ_fern_value

##Rename heads of columns of dist2 matrix
fernvalue<- summ_fern_value %>% rename(value = min)
fernvalue

## select forest pixel that match pixel of fern and values
neardistance <- right_join(dist2_id,fernvalue, by=c("value","fern"))
neardistance

##############################################################
################  Igraph package #############################
##############################################################

library(igraph)
library(sf)
library(rgdal)

########## extract coords

#library(tidyverse)
#library(tibble)
#library(devtools)
#library(usethis)



######### Duplicate and Extract coordinates

library (sf)
library(sp)


#class(df)
#colnames(df)

# [1] "ID_pixel" "Long"     "Lat"      "ID_veg"   "loc"      "ndvi"     "ID.x"    
# [8] "z"        "ID.y"     "x"        "y"

#df$East=df$x
#df$North=df$y
#colnames(df)
#class(df)


#df_spat=st_as_sf(df, coords = c("x", "y"), crs = ("+init=epsg:32717"))
#df_spat

#coordnt <- st_as_sf(df_spat, df_spat = c("x", "y"),
 #                  crs = 32717, stringsAsFactors = FALSE)
#class(coordnt)

#colnames(coordnt)
#class(coordnt)
#coordnt <- coordnt %>% rename(GEOMETRY=geometry)
#coordnt
#class(coordnt)

##### arrange

#library(dplyr)

#class(coordnt)


### Convert raster to polygon###

#elev_utm

#elev_utm_poly = rasterToPolygons(elev_utm,na.rm=TRUE)

#class(elev_utm_poly)

elev

elev_poly = rasterToPolygons(elev,na.rm=TRUE)
class(elev_poly)



## save shapefile elev_utm_poly in folder
#writeOGR(elev_utm_poly,"elev_utm_shape", dsn="C:/Users/Sandra/Desktop/R files/Stats/RMarkdownAssignment_Sandra/datatemp", driver="ESRI Shapefile",overwrite=TRUE)


writeOGR(elev_poly,"elev_shape", dsn="C:/Users/Sandra/Desktop/R files/Stats/RMarkdownAssignment_Sandra/datatemp", driver="ESRI Shapefile",overwrite=TRUE)



## call shapefile elev_utm_shape and transform into sf file
#elev_utm_shape <- st_read("elev_utm_shape.shp")%>%
 #      st_transform(crs = 32717)
#class(elev_utm_shape)


elev_shape <- st_read("C:/Users/Sandra/Desktop/R files/Stats/RMarkdownAssignment_Sandra/datatemp/elev_shape.shp")%>%
       st_transform(crs = 32717)
class(elev_shape)


###create an hexagonal grid
#hex_elev_utm_shape <- st_make_grid(elev_utm_shape, cellsize = 10, square = FALSE)
#hex_elev_utm_shape

#plot(hex_elev_utm_shape,axes=TRUE,col="green",pch=19,cex=.5,xlab="East", ylab="North")


hex_elev_shape <- st_make_grid(elev_shape, cellsize = 8, square = FALSE)
hex_elev_shape

plot(hex_elev_shape,axes=TRUE,col="green",pch=19,cex=.5,xlab="East", ylab="North")



############ Create an igraph network, it will represent neighbouring cells


## we need to create an igraph network.
## We must first create an edgelist (i.e. list to ‘from’ and ‘to’ cell id’s that represent neighbours), then convert into a network.

edgelist <- as.matrix(as.data.frame(st_intersects(hex_elev_shape)))

  # yes, the as.matrix and as.data.frame is a bit silly, but required to have the right format
edgelist


gr <- graph_from_edgelist(edgelist, directed=TRUE)

#### distance between each neighbouring cell is 50m since we defined this when we created the grid
E(gr)$weight <- 8


## We just need to figure out where the stations are relative to the hexagonal grid.
hex_pixels <- as.numeric(st_intersects(coordnt, hex_elev_shape))
hex_pixels

hex_pixels <- unique(as.numeric(st_intersects(coordnt, hex_elev_shape)))
hex_pixels

dist3 <- distances(gr, hex_pixels[(1:56)], hex_pixels[-(1:56)])
dim(dist3)
class(dist3)

#dist3_df <- data.frame(dist3, row.names = "ID_veg")

##drop geometry
coord_df <- st_drop_geometry(coordnt)

### Subset columns from datafrane coordnt
ID_pixels<-coord_df[, 1]
ID_pixels

### Assign ID names to row and columns of dist2 matrix
rownames(dist3) <- ID_pixels[1:56]
dist3
colnames(dist3) <- ID_pixels[57:96]
dist3

# Convert dist3 matrix into dataframe using reshape2 package
library(reshape2)

#rename heads of columns of dist2 matrix
dist3_id <- melt(as.matrix(dist3), varnames = c("fern", "forest"))
dist3_id

### convert into dataframe
dist3_id[dist3_id$fern > dist3_id$forest,]
view(dist3_id)

### Select minimun distance values.
library(dplyr)

igraph_fern_value<- dist3_id %>% 
  group_by(fern) %>% 
  summarise(min = min(value, na.rm = TRUE))

## Rename heads of columns of dist3 matrix
igraphfernvalue<- igraph_fern_value %>% rename(value = min)
view(igraphfernvalue)

## Select forest pixel that match pixel of fern and values
igraphneardistance <-right_join(dist3_id,igraphfernvalue, by=c("value","fern"))
view(igraphneardistance)


##############################################################
################ Euclidean function #############################
##############################################################

###################### measure distance #######################
 distxyz.fx=function(x1,x2,y1,y2,z1,z2){
  sqrt((x1-x2)^2+(y1-y2)^2+(z1-z2)^2)
}
dist.fx=function(x1,x2,y1,y2){
  sqrt((x1-x2)^2+(y1-y2)^2)
}

df
#pix=read.csv("pixelelev.csv")
#df=read.csv("df.csv")
df_forest=df[df$ID_veg=="forest",]
df_fern=df[df$ID_veg=="fern",]
distmat=matrix(NA,nrow=nrow(df_fern),ncol=nrow(df_forest))
for(i in 1:nrow(df_fern)){
  distmat[i,]=distxyz.fx(df_fern$x[i],df_forest$x,
                         df_fern$y[i],df_forest$y,
                         df_fern$z[i],df_forest$z)
  # distmat[i,]=dist.fx(df_fern$x[i],df_forest$x,
  #                     df_fern$y[i],df_forest$y)
}
# distmat is now a distnace matrix containing pairwise distances between fern patches and forest patches
distmat

# now we need to select the nearest forest patch for each fern patch
nearest_forest_id=rep(NA, nrow(df_fern))
nearest_forest_dist=rep(NA, nrow(df_fern))
for(i in 1:length(nearest_forest_id)){
  nearest_forest_id[i] = which(distmat[i,] == range(distmat[i,])[1])
  nearest_forest_dist[i] = distmat[i, which(distmat[i,] == range(distmat[i,])[1])]
}
df_fern$nearForestID=nearest_forest_id
df_fern$nearForestDist=nearest_forest_dist

df_fern$nearForestDist
##plot distance

plot(df$x,df$y,cex=.001)
points(df_fern$x,df_fern$y,col="black",pch=19,cex=.5)
points(df_forest$x[df_fern$nearForestID],
       df_forest$y[df_fern$nearForestID],col="green",pch=19,cex=1)
points(df_forest$x,df_forest$y,col="blue",cex=.5)



#Check the outcomes? How will you know if your steps worked?

# 
```

## Introduce the packages
Given your psuedo code, where is the critical step? What packages and functions are you considering to help you complete this step? Why did you choose them? 


library(here)
library(raster)
library(rasterVis)
library(rgdal)
library(viridis)
library(scales)
library(maptools)
library(rgeos)
library(dplyr)
library(RColorBrewer)
library(ggplot2)






## Evaluate your choices
Use profiling and benchmarking to evaluate which of your options is likely to be the fastest. How does the syntax and/or ease of use of that function impact your decision of whether or not to use it? (For example, velox is much faster than raster, but it's less well documented and the syntax is strange to get used to).








## Show us your final product
Did you make a map? Let's see it. Did you plot some data that you extracted with raster? show us that plot. Did you have an idea of how the data should look after you were done processing it? Were you successful? What went wrong


plot(df$x,df$y,cex=.001)
points(df_fern$x,df_fern$y,col="black",pch=19,cex=.5)
points(df_forest$x[df_fern$nearForestID],
       df_forest$y[df_fern$nearForestID],col="green",pch=19,cex=1)
points(df_forest$x,df_forest$y,col="blue",cex=.5)




## Reflect
Write a few sentences on what you learned from this exercise. How has your skill improved? What do you wish you understood better? What do you imagine your next steps to be?

Once you're done push the "knit" button to create the html page from your Rmarkdown document. If you've got questions, let me know!!
